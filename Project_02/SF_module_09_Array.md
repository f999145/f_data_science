# NumPy Array



```python
import numpy as np
```

## Создать массив из списка можно с помощью функции np.array(<объект>)

```python
import numpy as np
arr = np.array([1,5,2,9,10])
arr
# array([ 1,  5,  2,  9, 10])
```

Функция np.array возвращает объекты типа numpy.ndarray:
>Название ndarray — это сокращение от n-dimensional array, n-мерный массив.

> __Таким образом, массивы в NumPy, даже одномерные, на самом деле хранятся в объекте, который позволяет работать с многомерными массивами.__

---
## Задать тип данных сразу при создании массива можно с помощью параметра dtype:

```python
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr
# array([ 1,  5,  2,  9, 10], dtype=int8)
```

### Будем тренироваться на массивах arr и nd_arr:

```python
arr = np.array([1,5,2,9,10], dtype=np.int8)
nd_arr = np.array([
               [12, 45, 78],
               [34, 56, 13],
               [12, 98, 76]
               ], dtype=np.int16)
```
### ***.dtype*** - Узнать тип данных массива
### ***.ndim*** - Узнать размерность массива
### ***.size*** - Узнать общее число элементов в массиве
### ***.shape*** - Форма или структура массива
### ***.itemsize*** - Сколько «весит» каждый элемент массива в байтах

### Поменять тип данных во всём массиве можно с помощью тех же функций, которыми мы пользовались для преобразования типов отдельных переменных в предыдущем юните (например, np.int32 или np.float128):
```python
arr = np.float128(arr)
arr
# array([ 1.,  5., 12.,  9., 10.], dtype=float128)
```

---
## Заполнение новых массивов
### Массив из нулей создаётся функцией ***np.zeros***. Она принимает аргументы ___shape___ (обязательный) — форма массива (одно число или кортеж) и ___dtype___ (необязательный) — тип данных, который будет храниться в массиве.

```python
zeros_3d = np.zeros((5,4,3), dtype=np.float32)
print(zeros_3d.shape)
# (5, 4, 3)
```

>Ещё одной удобной функцией для создания одномерных массивов является ***arange***([start,] stop, [step,], dtype=None).


### ***linspace*** (англ. linear space — линейное пространство). Она тоже возвращает одномерный массив из чисел, расположенных на равном удалении друг от друга между началом и концом диапазона, но обладает немного другим поведением и сигнатурой
### ***np.linspace***(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

- start и stop являются обязательными параметрами, задающими начало и конец возвращаемого диапазона;
- num — параметр, задающий число элементов, которое должно оказаться в массиве (по умолчанию 50);
- endpoint — включён или исключён конец диапазона (по умолчанию включён);
- retstep (по умолчанию False) позволяет указать, возвращать ли использованный шаг между значениями, помимо самого массива;
- dtype — уже хорошо знакомый нам параметр, задающий тип данных (если не задан, определяется автоматически).

Узнаем, какой шаг был использован для создания массива из десяти чисел между 1 и 2, где 2 включалось и не включалось:

```python
arr, step = np.linspace(1, 2, 10, endpoint=True, retstep=True)
print(step)
# 0.1111111111111111

arr, step = np.linspace(1, 2, 10, endpoint=False, retstep=True)
print(step)
# 0.1
```
---
## Изменение формы массива

### ***.shape = (n, )*** - С помощью присввоения кортежа атрибуту _.shape_
### ****.reshape((n, ))*** - Изменяем форму массива (не изменяя исходный) и присваеваем новому массиву:

```python
arr = np.arange(8)
arr_new = arr.reshape((2, 4))
arr_new
# array([[0, 1, 2, 3],
#       [4, 5, 6, 7]])
```

>---
>У функции reshape есть дополнительный именованный аргумент order. Он задаёт принцип, по которому элементы заполняют массив новой формы. Если order='C' (по умолчанию), массив заполняется по строкам, как в примере выше. Если order='F', массив заполняется числами по столбцам:
>```python
>arr = np.arange(8)
>arr_new = arr.reshape((2, 4), order='F')
>arr_new
># array([[0, 2, 4, 6],
>#       [1, 3, 5, 7]])
>```
> ---

### ***.transpose()*** - Эта функция меняет строки и столбцы массива местами

```python
arr_trans = arr.transpose()
arr_trans
# array([[0, 4],
#        [1, 5],
#        [2, 6],
#        [3, 7]])
```
---
## Индексы и срезы в массивах
Обратиться к его элементу по индексу можно так же, как и к списку:
```python
print(arr[2])
# 2
```
Привычная запись для срезов работает и для одномерных массивов:
```python
print(arr[2:4])
# [2 3]
```
Наконец, напечатать массив в обратном порядке можно с помощью привычной конструкции [::-1]:

### В многомерных массивах достаточно указывать индексы в квадратных скобках через запятую [n1,n2,n3,...]

```python
nd_array[1:, 2:4]
#[[ 6.  7.]
# [10. 11.]]

nd_array[:, 2:4]
#[[ 2.  3.]
# [ 6.  7.]
# [10. 11.]]

nd_array[:2]
#[[0. 1. 2. 3.]
# [4. 5. 6. 7.]]

```
---
## Сортировка одномерных массивов
>_
>
>Способ 1. Функция np.sort(<массив>) возвращает новый отсортированный массив:
>```python
>arr = np.array([23,12,45,12,23,4,15,3])
>arr_new = np.sort(arr)
>print(arr)
># [23 12 45 12 23  4 15  3]
>print(arr_new)
># [ 3  4 12 12 15 23 23 45]
>```
>---
>Способ 2. Функция <массив>.sort() сортирует исходный массив и возвращает None:
>```python
>arr = np.array([23,12,45,12,23,4,15,3])
>print(arr.sort())
># None
>print(arr)
># [ 3  4 12 12 15 23 23 45]
>```
>_

---

## Работа с пропущенными данными

создадим массив:
```python
data = np.array([4, 9, -4, 3])
```
Воспользуемся встроенной в NumPy функцией ***sqrt***, чтобы посчитать квадратные корни из элементов.
```python
roots = np.sqrt(data)
roots
# RuntimeWarning: invalid value encountered in sqrt
# array([2.        , 3.        ,        nan, 1.73205081])
```
>NumPy выдал предупреждение о том, что в функцию sqrt попало некорректное значение. Это было число -4, а как вы помните, корень из отрицательного числа в действительных числах не берётся. Однако программа не сломалась окончательно, а продолжила работу. На том месте, где должен был оказаться корень из -4, теперь присутствует объект nan. Он расшифровывается как Not a number (не число). Этот объект аналогичен встроенному типу None, но имеет несколько отличий

Если попробовать посчитать сумму массива, который содержит np.nan, в итоге получится nan:
```python
sum(roots)
# nan
```
Можно заполнить пропущенные значения, например, нулями. Для этого с помощью функции np.isnan(<массив>) узнаем, на каких местах в массиве находятся «не числа»:
```python
np.isnan(roots)
# array([False, False,  True, False])
```
Можно использовать полученный массив из True и False для извлечения элементов из массива roots, на месте которых в булевом массиве указано True. Таким способом можно узнать сами элементы, которые удовлетворяют условию np.isnan:
```python
roots[np.isnan(roots)]
# array([nan])
```
Этим элементам можно присвоить новые значения, например 0:
```python
roots[np.isnan(roots)] = 0
roots
# array([2.        , 3.        , 0.        , 1.73205081])
```
После этого, если пропущенных значений больше нет, можем подсчитать сумму элементов массива:
```python
sum(roots)
# 6.732050807568877
```

## Операции с векторами

### ***np.linalg.norm( vector )*** - длина вектора

### ***np.linalg.norm( vec1 - vec2 )*** - расстояние между векторами
### ***np.dot(vec1, vec2)*** - скалярное произведение векторов

[Статистика NumPy](https://pyprog.pro/statistics_functions/statistics_function.html)

## Случайные числа в NumPy

### ***np.random.rand(n,)*** - генератор случайных чисел, где n, - размерность массива, если присутствует. В случае отсутствия просто число.

### ***np.random.sample(shape)*** - генератор случайных чисел, где *shape* кортеж

### ***np.uniform(low=0.0, high=1.0, size=None)*** low - нижняя граница рандома, high - верхняя граница рандома, size - картеж с размерность. массива.

### ***randint(low, high=None, size=None, dtype=int)*** - Функцию randint нельзя запустить совсем без параметров, необходимо указать хотя бы одно число.

* Если указан только аргумент low, числа будут генерироваться от 0 до low-1, то есть верхняя граница не включается.
* Если задать low и high, числа будут генерироваться от low (включительно) до high (не включительно).
* size задаёт форму массива уже привычным для вас образом: одним числом — для одномерного или кортежем — для многомерного.
* dtype позволяет задать конкретный тип данных, который должен быть использован в массиве.


## Генерация выборок

### ***np.random.shuffle( Array )*** - Функция перемешивает тот массив, к которому применяется, и возвращает None.

### ***np.random.permutation( Array или N )*** - функция возвращает новый меремешаный массив не изменяя исходный. или же возвращает перемешаный массив с числами от 0 до n-1.

### ***np.choice(a, size=None, replace=True)*** послучаем случайный набор из массива

* a — массив или число для генерации arange(a);
* size — желаемая форма массива (число для получения одномерного массива, кортеж — для многомерного; если параметр не задан, возвращается один объект);
* replace — параметр, задающий, могут ли элементы повторяться (по умолчанию могут).

```python
workers = ['Ivan', 'Nikita', 'Maria', 'John', 'Kate']
 
choice = np.random.choice(workers, size=2, replace=False)
print(choice)
```
### ***np.random.seed(<np.uint32>)*** - Задания ключа для генератора случайных чисел.

