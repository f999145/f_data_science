# NumPy Array



```python
import numpy as np
```

## Создать массив из списка можно с помощью функции np.array(<объект>)

```python
import numpy as np
arr = np.array([1,5,2,9,10])
arr
# array([ 1,  5,  2,  9, 10])
```

Функция np.array возвращает объекты типа numpy.ndarray:
>Название ndarray — это сокращение от n-dimensional array, n-мерный массив.

> __Таким образом, массивы в NumPy, даже одномерные, на самом деле хранятся в объекте, который позволяет работать с многомерными массивами.__


## Задать тип данных сразу при создании массива можно с помощью параметра dtype:

```python
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr
# array([ 1,  5,  2,  9, 10], dtype=int8)
```

### Будем тренироваться на массивах arr и nd_arr:

```python
arr = np.array([1,5,2,9,10], dtype=np.int8)
nd_arr = np.array([
               [12, 45, 78],
               [34, 56, 13],
               [12, 98, 76]
               ], dtype=np.int16)
```
### Узнать тип данных массива можно с помощью ___ .dtype ___:
### Узнать размерность массива можно с помощью ___ .ndim ___:
### Узнать общее число элементов в массиве можно с помощью ___.size ___:
### Форма или структура массива хранится в атрибуте ___ .shape ___:
### Наконец, узнать, сколько «весит» каждый элемент массива в байтах позволяет ___ .itemsize ___:


## Заполнение новых массивов
### Массив из нулей создаётся функцией np.zeros. Она принимает аргументы ___shape___ (обязательный) — форма массива (одно число или кортеж) и ___dtype___ (необязательный) — тип данных, который будет храниться в массиве.

```python
zeros_3d = np.zeros((5,4,3), dtype=np.float32)
print(zeros_3d.shape)
# (5, 4, 3)
```

>Ещё одной удобной функцией для создания одномерных массивов является arange. Она аналогична встроенной функции range, но обладает рядом особенностей. Вот её сигнатура: arange([start,] stop, [step,], dtype=None).


### На самом деле операции с плавающей точкой не всегда бывают предсказуемыми из-за особенностей хранения таких чисел в памяти компьютера. Поэтому для работы с дробными параметрами start, stop и step лучше использовать функцию linspace (англ. linear space — линейное пространство). Она тоже возвращает одномерный массив из чисел, расположенных на равном удалении друг от друга между началом и концом диапазона, но обладает немного другим поведением и сигнатурой
### ___np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)___

- start и stop являются обязательными параметрами, задающими начало и конец возвращаемого диапазона;
- num — параметр, задающий число элементов, которое должно оказаться в массиве (по умолчанию 50);
- endpoint — включён или исключён конец диапазона (по умолчанию включён);
- retstep (по умолчанию False) позволяет указать, возвращать ли использованный шаг между значениями, помимо самого массива;
- dtype — уже хорошо знакомый нам параметр, задающий тип данных (если не задан, определяется автоматически).

Узнаем, какой шаг был использован для создания массива из десяти чисел между 1 и 2, где 2 включалось и не включалось:

```python
arr, step = np.linspace(1, 2, 10, endpoint=True, retstep=True)
print(step)
# 0.1111111111111111

arr, step = np.linspace(1, 2, 10, endpoint=False, retstep=True)
print(step)
# 0.1
```